# React

> 是由 Facebook 研发到的，严格来说不是框架，而是用于解决 UI 复杂的开源的 js 库，目前由 React 社区联合维护。

## 站点

1. 无论是 Vue，还是 React，开发的单页应用程序，可能只是该站点的一部分（某一个功能块）

2. 一个单页应用程序，可能会划分为多个页面（几乎完全不同的页面效果）（组件）

3. 如果要在单页应用中完成组件的切换，需要实现下面两个功能：

1）根据不同的页面地址，展示不同的组件（核心）

2）完成无刷新的地址切换

> 把实现上述两个功能的插件，叫做 “路由”

## Redux

1. Flux：FaceBook 提出的数据解决方案，引入了 action 概念

> action：一个普通的对象，用于描述要干什么。action 是触发数据变化的唯一原因

> store：数据仓库，用于存储共享的数据。还可以根据不同的 action 更改仓库中的数据

```js
const loginAction = {
  type: "login",
  payload: {
    loginId: "admin",
    loginPwd: "123",
  },
};

const deleteAction = {
  type: "delete",
  payload: 1, // 用户id为1
};
```

2. Redux：在 Flux 的基础上，引入了 reducer 的概念

> reducer：处理器（类似于 controller），用于根据 action 来处理数据，处理后的数据会被仓库重新保存

### Middleware

1. 类似于高阶组件，在不影响原有功能、并不改动原本代码的基础上，增添了新的功能

2. 实现原理是：更改 dispatch 函数

3. 接收一个 store 对象，该 store 并非是一个完整的 store，仅有 getState、dispatch

1）该函数的运行时间点在创建 store 后

2）在创建 store 的时候，告诉仓库有哪些中间价

3）调用 applyMiddleware 函数，将函数的返回结果作为 createStore 的第二个或第三个参数

4. applyMiddleware 函数，记录有哪些中间件，返回一个函数，表示创建的 store，又返回一个函数，需要用到的 reducer

```js 应用 applyMiddleware
const store = createStore(reducer, [默认值], applyMiddleware(中间件1, 中间件2, ......));

const store = applyMiddleware(中间件1, 中间件2, ......)(createStore)(reducer, [默认值]);
```

```js 实现中间件
function logger(store) {
  return function (next) {
    return function (action) {
      // 需要实现的代码
      // 数据是之前的
      next(action); // 分发action，更改数据
      // 需要实现的代码
      // 数据是更新后的
    };
  };
}

const logger = (store) => (next) => (action) => {
  // 需要实现的代码
  // 数据是之前的
  next(action); // 分发action，更改数据
  // 需要实现的代码
  // 数据是更新后的
};
```

5. 创建中间件的时候，采用的方式类似于 webpack 处理 plugin 的形式（从后往前调用），中间件会将 store.dispatch 一层一层传递，最终的 store.dispatch 是最后一个中间件处理后的结果，如果要进行数据的更改，需要调用第二个参数（next / dispatch）

### 生成器

1. 由构造函数 Generator 创建的对象，该对象是既是一个迭代器，又是一个可迭代对象（满足可迭代协议）

2. Generator 构造函数，不提供给开发者使用，仅作为 JS 引擎内部使用

```js 伪代码
const generator = new Generator();
generator.next(); // 具有next方法
const iterator = generator[Symbol.iterator]; // 也是一个可迭代对象
for (const item of generator) {
  // 由于它是一个可迭代对象，因此可以使用for-of循环
}
```

3. ES6 新增语法，在函数前家加上一个\*号，该函数就是生成器函数

4. 调用生成器函数，会返回一个生成器，而不是执行函数体，函数体的运行受到生成器的控制

5. 每当调用 next 方法时，生成器的函数体会从上一个 yield 位置（或开始位置）运行到下一个 yield 位置

```js
yield 关键字只能在生成器内部使用，不可以用在普通函数中
      它表示暂停，并返回一个当前迭代的数据
      如果没有下一个yield，到了函数结束，则生成器的next方法中得到的done为true，value为undefined
```

6. 生成器函数的返回值，会作为迭代结束的 value，在结束后，得到的 value 一直是 undefined

7. 生成器调用 next 方法时，可以传递参数，该参数会作为生成器函数体的上一个 yield 表达式的值，第一次传递无效

8. 生成器有一个 throw 方法，该方法与 next 类似，唯一的区别是：next 方法传递的参数会被返回一个正常值，throw 传递的参数是一个错误对象，会导致生成器内部发送错误

9. 生成器有一个 return 方法，会直接结束生成器函数体的运行

10. 如果要在生成器函数内，调用其它的生成器，需要加上\*号，进行被调用的生成器函数内部执行函数体（ yield\* 生成器函数() ）
