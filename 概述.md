# React

> 是由 Facebook 研发到的，严格来说不是框架，而是用于解决 UI 复杂的开源的 js 库，目前由 React 社区联合维护。

## Context

> 上下文对象，表示某些事情的环境

### 特点

- 会破坏组件的纯粹性（由属性或状态传递数据）

1. 一般用于第三方组件（通用组件）

2. 会创建上下文区域，可以由子组件共享

### 旧版（React 16.0.0 之前）

_只有类组件，才可以创建上下文_

1. 对于类组件，需要静态属性，static childContextTypes 创建，并指明类型

> 提供了一个 getChildContext 方法，申明上下文对象中的属性和值，会在每次 render 后执行

> 子组件通过静态属性 static contextTypes 申明需要使用的上下文对象，并指明类型

> constructor，第二个参数传入如果要使用，在 super 的时候，也要传入 context，会绑定到该组件的 this 身上

2. 对于函数组件，会作为第二个参数传入

> 可以把 context 当作是一个特殊的 props。如果要想在子组件上掉用父组件的方法，传递处理函数即可

> 上下文中的数据不能直接改变，最终都是通过状态改变的

**遵循的原则是：就近原则，如果自身也创建了上下文对象，不会取自身的。如果创建的上下文出现了同名，会进行覆盖，子组件中使用新的上下文的属性的值**

### 新版（React 16.0.0.0 之后，包含）

_旧版 API 存在严重的效率问题，并容易导致滥用_

> 上下文对象与组件完全脱离，只是一个对象，通过 React.createContext 创建，可以给默认值，返回到的是两个属性（provider、consumer）的对象

- ctx.provider / ctx.consumer

> Provider：生产者，一个组件，该组件会创建一个上下文，该组件有一个属性，通过该属性，可以为其数据赋值

- 同一个 Provider，不要多次使用。如果需要在其他组件中使用数据，应该考虑的是将数据提升到更高的层次

> Consumer：使用者，一个组件，该组件会使用 Provider 的数据，会将Provider共享的数据放到一个函数中，作为第一个参数传入，返回一个React元素进行渲染

- 它的子节点必须是一个函数（props.children）

**遵循的原则是：在哪个 consumer 中使用，使用的数据就是来自哪个上下文对象中的**

_如果 provider 中的数据发生了变化，无论子组件是否进行了优化（shouldComponentUpdate 的值为 true 还是 false），都会进行重新渲染，即使是传递了空对象，因为调用 setState 的时候，总是会创建一个新的对象。React 使用的是 Object.is 进行比较，比较的是两者的引用地址。解决办法是：在传入的数据外，再包裹一层，作为属性的值传递。由此，即使是新的对象，但是原有的属性没变，指向的地址也没变，所以，可以根据 shouldComponentUpdate 的值来进行优化_
