# React

> 是由 Facebook 研发到的，严格来说不是框架，而是用于解决 UI 复杂的开源的 js 库，目前由 React 社区联合维护。

## 站点

1. 无论是 Vue，还是 React，开发的单页应用程序，可能只是该站点的一部分（某一个功能块）

2. 一个单页应用程序，可能会划分为多个页面（几乎完全不同的页面效果）（组件）

3. 如果要在单页应用中完成组件的切换，需要实现下面两个功能：

1）根据不同的页面地址，展示不同的组件（核心）

2）完成无刷新的地址切换

> 把实现上述两个功能的插件，叫做 “路由”

## Redux

1. Flux：FaceBook 提出的数据解决方案，引入了 action 概念

> action：一个普通的对象，用于描述要干什么。action 是触发数据变化的唯一原因

> store：数据仓库，用于存储共享的数据。还可以根据不同的 action 更改仓库中的数据

```js
const loginAction = {
  type: "login",
  payload: {
    loginId: "admin",
    loginPwd: "123",
  },
};

const deleteAction = {
  type: "delete",
  payload: 1, // 用户id为1
};
```

2. Redux：在 Flux 的基础上，引入了 reducer 的概念

> reducer：处理器（类似于 controller），用于根据 action 来处理数据，处理后的数据会被仓库重新保存

### Middleware

1. 类似于高阶组件，在不影响原有功能、并不改动原本代码的基础上，增添了新的功能

2. 实现原理是：更改 dispatch 函数

3. 接收一个 store 对象，该 store 并非是一个完整的 store，仅有 getState、dispatch

1）该函数的运行时间点在创建 store 后

2）在创建 store 的时候，告诉仓库有哪些中间价

3）调用 applyMiddleware 函数，将函数的返回结果作为 createStore 的第二个或第三个参数

4. applyMiddleware 函数，记录有哪些中间件，返回一个函数，表示创建的 store，又返回一个函数，需要用到的 reducer

```js 应用 applyMiddleware
const store = createStore(reducer, [默认值], applyMiddleware(中间件1, 中间件2, ......));

const store = applyMiddleware(中间件1, 中间件2, ......)(createStore)(reducer, [默认值]);
```

```js 实现中间件
function logger(store) {
  return function (next) {
    return function (action) {
      // 需要实现的代码
      // 数据是之前的
      next(action); // 分发action，更改数据
      // 需要实现的代码
      // 数据是更新后的
    };
  };
}

const logger = (store) => (next) => (action) => {
  // 需要实现的代码
  // 数据是之前的
  next(action); // 分发action，更改数据
  // 需要实现的代码
  // 数据是更新后的
};
```

5. 创建中间件的时候，采用的方式类似于 webpack 处理 plugin 的形式（从后往前调用），中间件会将 store.dispatch 一层一层传递，最终的 store.dispatch 是最后一个中间件处理后的结果，如果要进行数据的更改，需要调用第二个参数（next / dispatch）

### 迭代器和可迭代协议

1. redux-thunk、redux-promise 两个中间件，将导致 action 不再纯净

2. redux-thunk 返回的 action 是一个函数

3. redux-promise 返回的 action 是一个 promise 对象，或 payload 是一个 promise 对象

4. redux-saga 将完美解决上述问题，既可以保持 action、action 创建函数、reducer 的纯净，又可以结合模块化的方式，并且功能强大

5. redux-saga 建立在 ES6 的生成器的基础上，要熟练地使用，必须理解生成器，要理解生成器，必须要理解迭代器和可迭代协议

#### 迭代

> 类似于遍历

1. 遍历：有多个数据组成的集合数据结构（map、set、array/等其他类型化数组），需要从该结构中依次取出数据进行某种处理

2. 迭代：按照某种逻辑，依次取出下一次数据进行处理

#### 迭代器

1. js 规定，如果一个对象具有 next 方法，并且 next 方法满足一定的约束，则该对象是一个迭代器

```js
next() {
  // 必须返回一个对象，该对象至少需要以下两种属性
  value: any类型，下一个数据的值
  done：bool类型，是否迭代完成
}
```

#### 迭代器创建函数

> 它是指一个函数，调用该函数，返回一个迭代器，则该函数被称之为迭代器创建函数，可以简称为迭代器函数

#### 可迭代协议

1. ES6 中的新 API（for-of）循环，该循环就是用于迭代某个对象，因此，for-of 循环的对象必须是可迭代的（对象满足可迭代协议）

2. 可迭代协议是用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可迭代的

```js
可迭代协议的约束：
1. 对象必须有一个知名符号 (Symbol.iterator)
2. 该属性必须是一个无参的 (迭代器创建函数)
```

#### for-of 循环的原理

> 调用对象的 [Symbol.iterator] 方法，得到一个迭代器。不断调用 next 方法，返回 value 的值，直到 done 为 true

```js
const iterator = (可迭代对象)obj[Symbol.iterator]();
let result = iterator.next();
while (!result.done) {
  console.log(result.value); // 得到当前迭代的数据
  result = iterator.next(); // 进行下一次迭代
}
```
